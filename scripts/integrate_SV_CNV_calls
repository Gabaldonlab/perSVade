#!/usr/bin/env python

######################################
############# DEFINE ENV #############
######################################

# general module imports
import argparse, os
from argparse import RawTextHelpFormatter
import copy as cp
import pickle
import string
import shutil 
import random
import sys
from shutil import copyfile
import time

# get the cwd were all the scripts are 
CWD = "/".join(__file__.split("/")[0:-1]); sys.path.insert(0, CWD)

# define the module name
module_name = __file__.split("/")[-1]

# define the EnvDir where the environment is defined
EnvDir = "/".join(sys.executable.split("/")[0:-2])

# import functions
import sv_functions as fun

# import perSVade-specific modules
import numpy as np
import pandas as pd

######################################
######################################
######################################


#################################### 
############## ARGS ################
####################################

description = """
This module takes the output of 'call_SVs' (through --outdir_callSVs) and the output of 'call_CNVs' (through --outdir_callCNVs) and integrates them into a single .vcf file. You can input SV and/or CNV calls. If both are provided, the CNV calls that overlap an equivalent SV call will be discarded in order to remove redundancy. The resulting .vcf file represents how each variant affects a genomic region, which is useful for further functional annotation (with the 'annotate_SVs' module). You can find more information on this encoding in https://github.com/Gabaldonlab/perSVade/wiki/8.-FAQs#what-is-in-sv_and_cnv_variant_callingvcf.
"""

# mandatory args
parser = argparse.ArgumentParser(description=description, formatter_class=RawTextHelpFormatter)
parser.add_argument("-o", "--outdir", dest="outdir", action="store", required=True, help="Output directory.")
parser.add_argument("-r", "--ref", dest="ref", required=True, help="Reference genome. It has to end with .fasta.")
parser.add_argument("-sbam", "--sortedbam", dest="sortedbam", required=True, help="The path to the sorted .bam file, which should have a bam.bai file in the same dir. For example, if your bam file is called 'aligned_reads.bam', there should be an 'aligned_reads.bam.bai' as well.")
parser.add_argument("-mchr", "--mitochondrial_chromosome", dest="mitochondrial_chromosome", required=True, type=str, help="The name of the mitochondrial chromosome. If there is no mitochondria just put 'no_mitochondria'. If there is more than one mitochindrial scaffold, provide them as comma-sepparated IDs, like '--mitochondrial_chromosome chr_mito_1,chr_mito_2'.")
parser.add_argument("--repeats_file", dest="repeats_file", required=True, help="A file with the repeats of the reference genome, such as the file 'combined_repeats.tab' generated by perSVade infer_repeats. You may set '--repeats_file skip' if you don't want to consider repeats.")
parser.add_argument("-p", "--ploidy", dest="ploidy", required=True, type=int, help="Ploidy, can be 1 or 2.")

# args of the inputs
parser.add_argument("--outdir_callSVs", dest="outdir_callSVs", default=None, help="The path to the output directory of the 'call_SVs' module. If provided, this module will integrate the SV calls.")
parser.add_argument("--outdir_callCNVs", dest="outdir_callCNVs", default=None, help="The path to the output directory of the 'call_CNVs' module. If provided, this module will integrate the CNV calls.")

# genral optional args
parser.add_argument("--min_chromosome_len", dest="min_chromosome_len", default=100000, type=int, help="The minimum length to consider chromosomes from the provided fasta for calculating the window length (used in may steps of perSVade to parallelize across fractions of the genome).")
parser.add_argument("--replace", dest="replace", action="store_true", help="Re-run all the steps by deleting the output directory.")
parser.add_argument("--verbose", dest="verbose", action="store_true", default=False, help="Print a verbose log.")

# resources
parser.add_argument("--fraction_available_mem", dest="fraction_available_mem", default=None, type=float, help="This pipeline calculates the available RAM for several steps, and it may not work well in some systems (i.e. HPC clusters). This parameter allows you to correct possible errors. If --fraction_available_mem is not provided (default behavior), this pipeline will calculate the available RAM by filling the memory, which may give errors. If you want to use all the available memory you should specify --fraction_available_mem 1.0. See the FAQ 'How does the --fraction_available_mem work?' from https://github.com/Gabaldonlab/perSVade/wiki/8.-FAQs for more info.")

parser.add_argument("-thr", "--threads", dest="threads", default=16, type=int, help="Number of threads, Default: 16")
parser.add_argument("--fractionRAM_to_dedicate", dest="fractionRAM_to_dedicate", type=float,  default=0.5, help="This is the fraction of the available memory that will be used by several java programs that require a heap size. By default we set this to 0.5 to not overload the system.")

opt = parser.parse_args()

####################################
####################################
####################################

#################################
########### MAIN CODE ###########
#################################

# remove outdir if replace, and set replace to False
if opt.replace is True: fun.delete_folder(opt.outdir)
opt.replace = False

# make the outdir
fun.make_folder(opt.outdir)

# exit if the final file exists
final_file = "%s/perSVade_finished_file.txt"%opt.outdir

if not fun.file_is_empty(final_file): 
    fun.print_with_runtime("WARNING: %s exists, suggesting that perSVade was already  run in this folder. Remove this file if you want this command to work. Exiting..."%final_file)
    sys.exit(0)

# define the start time
start_time = time.time()

# define the verbosity. If opt.verbose is False, none of the 'print' statements of sv_functions will have an effect
fun.printing_verbose_mode = opt.verbose

# define a file that will contain all the cmds ran
fun.log_file_all_cmds = "%s/all_cmds.txt"%opt.outdir
if fun.file_is_empty(fun.log_file_all_cmds): open(fun.log_file_all_cmds, "w").write("# These are all the cmds:\n")

# get sample name
sample_name = fun.get_sampleName_from_perSVade_outdir(opt.outdir)

####### SET RESOURCES ########

# define the fraction of RAM to dedicate
if opt.fractionRAM_to_dedicate>0.95: raise ValueError("You are using >95 pct of the systems RAM, which is dangerous")
fun.fractionRAM_to_dedicate = opt.fractionRAM_to_dedicate

# define the fraction of available mem
fun.fraction_available_mem = opt.fraction_available_mem
if opt.fraction_available_mem is None: fun.print_with_runtime("WARNING: You did not specify how much RAM should be used through --fraction_available_mem. perSVade will calculate this by filling the memory, which may be dangerous. If you want to use all the allocated memory you should specify --fraction_available_mem 1.0")

# print the available resources
real_available_threads = fun.get_available_threads(opt.outdir)
if opt.threads>real_available_threads:  fun.print_with_runtime("WARNING: There are %i available threads, and you required %i."%(real_available_threads, opt.threads))


available_Gb_RAM = fun.get_availableGbRAM(opt.outdir)
fun.print_with_runtime("Running perSVade %s into %s with %.3f Gb of RAM and %i cores"%(module_name, opt.outdir, available_Gb_RAM, opt.threads))

##############################

# debug the fact that you did not provide any calls to integrate
if opt.outdir_callSVs is None and opt.outdir_callCNVs is None: raise ValueError("You should provide --CNV_calls and/or --outdir_callSVs")

# prepare the reference genome
opt.ref, reference_genome_dir = fun.prepare_reference_genome_for_perSVade(opt.ref, opt.outdir, opt.mitochondrial_chromosome, None, opt.replace)
fun.window_l = fun.get_perSVade_window_l(opt.ref, opt.mitochondrial_chromosome, opt.min_chromosome_len)

# prepare the repeats file
fun.prepare_repeats_file_for_perSVade(opt.repeats_file, opt.ref)

# get the bam file under output
sorted_bam, index_bam = fun.get_sorted_bam_in_outdir(opt.sortedbam, opt.outdir)

#### LOAD CNV-RELATED DATA ####

# define the expected cnv calling algs
all_expected_cnv_calling_algs = {"HMMcopy", "AneuFinder", "CONY"}

# load the df_CNV_coverage and debug CNV-related args
fun.print_with_runtime("Loading CNV data")
if opt.outdir_callCNVs is not None: 

    # load the df with the CNV calls
    df_CNV_coverage = fun.get_tab_as_df_or_empty_df("%s/final_CNVcalling.tab"%opt.outdir_callCNVs)

    # define the calling algs and debug
    cnv_calling_algs = {k.split("_")[-1] for k in df_CNV_coverage.keys() if k.startswith("median_relative_CN_")}
    
    strange_cnv_calling_algs = cnv_calling_algs.difference(all_expected_cnv_calling_algs)
    if len(strange_cnv_calling_algs)>0: raise ValueError("the cnv calling algs specfied with --cnv_calling_algs are wrong. These are the unexpected ones:%s. This suggests that the file provided in --CNV_calls is not in the correct format."%strange_cnv_calling_algs)
    if len(cnv_calling_algs)==0: raise ValueError("There are no CNV calling args, suggesting that the file provided in --CNV_calls is not in the correct format")

    # get the min_CNVsize_coverageBased as the smallest CNV. This is to not filter anything
    fun.min_CNVsize_coverageBased = min(df_CNV_coverage.end-df_CNV_coverage.start) - 1

    # define the window_size_CNVcalling from the final_df_coverage.tab
    df_coverag_windows = fun.get_tab_as_df_or_empty_df("%s/final_df_coverage.tab"%opt.outdir_callCNVs)
    window_size_CNVcalling = int(np.median(df_coverag_windows.end-df_coverag_windows.start))

else: 

    # get the calling algs
    cnv_calling_algs = all_expected_cnv_calling_algs

    # get an empty df
    df_CNV_coverage = pd.DataFrame(columns=(["chromosome", "merged_relative_CN", "start", "end", "CNVid", "median_coverage", "median_coverage_corrected", "SVTYPE"] + ["median_relative_CN_%s"%x for x in sorted(cnv_calling_algs)]))

    # define window_size_CNVcalling
    window_size_CNVcalling = None

###############################

####### LOAD SV-RELATED DATA ##########

fun.print_with_runtime("Loading SV data")
if opt.outdir_callSVs is not None: 

    # get all the files of outdir_callSVs softlinked under outdir
    outdir_callSVs = "%s/outdir_callSVs"%opt.outdir
    fun.soft_link_folders(opt.outdir_callSVs, outdir_callSVs)

    # get the files necessary to integrate the dfs
    svtype_to_svfile, df_gridss = fun.get_svtype_to_svfile_and_df_gridss_from_call_SVs_outdir(outdir_callSVs, opt.ref)
    outfile_clove = "%s/clove_output.vcf"%outdir_callSVs

else:

    # define vcf fields
    vcf_fields = ["#CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT"]

    # get empty objects
    svtype_to_svfile = {}
    df_gridss = pd.DataFrame(columns=(vcf_fields+["eventID_as_clove"]))

    # get an empty file for clove
    outfile_clove = "%s/empty_clove_outfile.vcf"%opt.outdir
    open(outfile_clove, "w").write("##fileformat=VCFv4.2\n"+("\t".join(vcf_fields)+"\n"))

#######################################

# log
fun.print_with_runtime("Integrating SV and CNV calls")

# run the integration
SV_CNV_vcf = fun.get_vcf_all_SVs_and_or_CNV(opt.outdir, sorted_bam, opt.ref, opt.ploidy, df_CNV_coverage, window_size_CNVcalling, cnv_calling_algs, svtype_to_svfile, df_gridss, outfile_clove, replace=opt.replace, threads=opt.threads, mitochondrial_chromosome=opt.mitochondrial_chromosome)

#################################
#################################
#################################


##################################
########## CLEAN OUTPUT ##########
##################################

# clean
files_folder_to_keep = {"all_cmds.txt", fun.get_file(SV_CNV_vcf)}

for f in os.listdir(opt.outdir): 
    file_path = "%s/%s"%(opt.outdir, f)
    if f not in files_folder_to_keep: fun.delete_file_or_folder(file_path)

# wite final file
fun.generate_final_file_report_one_module(final_file, start_time, time.time())

# print the message
fun.print_with_runtime("perSVade %s finished correctly"%module_name)

##################################
##################################
##################################
