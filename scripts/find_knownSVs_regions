#!/usr/bin/env python

######################################
############# DEFINE ENV #############
######################################

# general module imports
import argparse, os
from argparse import RawTextHelpFormatter
import copy as cp
import pickle
import string
import shutil 
import random
import sys
from shutil import copyfile
import time

# get the cwd were all the scripts are 
CWD = "/".join(__file__.split("/")[0:-1]); sys.path.insert(0, CWD)

# define the module name
module_name = __file__.split("/")[-1]

# define the EnvDir where the environment is defined
EnvDir = "/".join(sys.executable.split("/")[0:-2])

# import functions
import sv_functions as fun

# import perSVade-specific modules
import pandas as pd

######################################
######################################
######################################


#################################### 
############## ARGS ################
####################################

description = """
Finds regions with perSVade-inferred SVs. It takes a file with short-read datasets (with --close_shortReads_table) and it runs perSVade's modules 'trim_reads_and_QC', 'align_reads' and 'call_SVs' on each of them. It combines the called SVs in each dataset into a single .bedpe file that can be used to define regions for SV simulation.
"""

parser = argparse.ArgumentParser(description=description, formatter_class=RawTextHelpFormatter)
parser.add_argument("-o", "--outdir", dest="outdir", action="store", required=True, help="Output directory.")
parser.add_argument("-r", "--ref", dest="ref", required=True, help="Reference genome. It has to end with .fasta.")
parser.add_argument("--SVcalling_parameters", dest="SVcalling_parameters", required=True, help="The SV calling parameters. It can be 'default' or a .json file with custom parameters. An example of such a .json script can be found in misc/default_perSVade_parameters.json of perSVade's github repository.")
parser.add_argument("-mchr", "--mitochondrial_chromosome", dest="mitochondrial_chromosome", required=True, type=str, help="The name of the mitochondrial chromosome. If there is no mitochondria just put 'no_mitochondria'. If there is more than one mitochindrial scaffold, provide them as comma-sepparated IDs, like '--mitochondrial_chromosome chr_mito_1,chr_mito_2'.")
parser.add_argument("--repeats_file", dest="repeats_file", required=True, help="A file with the repeats of the reference genome, such as the file 'combined_repeats.tab' generated by perSVade infer_repeats. You may set '--repeats_file skip' if you don't want to consider repeats for SV filtering.")
parser.add_argument("--close_shortReads_table", dest="close_shortReads_table", type=str, required=True, help="Path to a table that has 3 fields: sampleID,short_reads1,short_reads2. These should be WGS runs of samples that are close to the reference genome (i.e. from the same species) and have some expected SV. This module will find SVs in each of them using the provided parameters(--ref, -mchr, --repeats_file, --SVcalling_parameters, --skip_marking_duplicates).")

parser.add_argument("--skip_marking_duplicates", dest="skip_marking_duplicates", default=False, action="store_true", help="Don't mark the duplicate reads in the .bam files generated by perSVade align_reads. This can save you some time.")
parser.add_argument("--min_chromosome_len", dest="min_chromosome_len", default=100000, type=int, help="The minimum length to consider chromosomes from the provided fasta for calculating the window length (used in may steps of perSVade to parallelize across fractions of the genome).")
parser.add_argument("--replace", dest="replace", action="store_true", help="Re-run all the steps by deleting the output directory.")
parser.add_argument("--verbose", dest="verbose", action="store_true", default=False, help="Print a verbose log.")

# resources
parser.add_argument("--fraction_available_mem", dest="fraction_available_mem", default=None, type=float, help="This pipeline calculates the available RAM for several steps, and it may not work well in some systems (i.e. HPC clusters). This parameter allows you to correct possible errors. If --fraction_available_mem is not provided (default behavior), this pipeline will calculate the available RAM by filling the memory, which may give errors. If you want to use all the available memory you should specify --fraction_available_mem 1.0. See the FAQ 'How does the --fraction_available_mem work?' from https://github.com/Gabaldonlab/perSVade/wiki/8.-FAQs for more info.")

parser.add_argument("-thr", "--threads", dest="threads", default=16, type=int, help="Number of threads, Default: 16")
parser.add_argument("--fractionRAM_to_dedicate", dest="fractionRAM_to_dedicate", type=float,  default=0.5, help="This is the fraction of the available memory that will be used by several java programs that require a heap size. By default we set this to 0.5 to not overload the system.")

opt = parser.parse_args()

####################################
####################################
####################################

#################################
########### MAIN CODE ###########
#################################

# remove outdir if replace, and set replace to False
if opt.replace is True: fun.delete_folder(opt.outdir)
opt.replace = False

# make the outdir
fun.make_folder(opt.outdir)

# exit if the final file exists
final_file = "%s/perSVade_finished_file.txt"%opt.outdir

if not fun.file_is_empty(final_file): 
    fun.print_with_runtime("WARNING: %s exists, suggesting that perSVade was already  run in this folder. Remove this file if you want this command to work. Exiting..."%final_file)
    sys.exit(0)

# define the start time
start_time = time.time()

# define the verbosity. If opt.verbose is False, none of the 'print' statements of sv_functions will have an effect
fun.printing_verbose_mode = opt.verbose

# define a file that will contain all the cmds ran
fun.log_file_all_cmds = "%s/all_cmds.txt"%opt.outdir
if fun.file_is_empty(fun.log_file_all_cmds): open(fun.log_file_all_cmds, "w").write("# These are all the cmds:\n")

# get sample name
sample_name = fun.get_sampleName_from_perSVade_outdir(opt.outdir)

####### SET RESOURCES ########

# define the fraction of RAM to dedicate
if opt.fractionRAM_to_dedicate>0.95: raise ValueError("You are using >95 pct of the systems RAM, which is dangerous")
fun.fractionRAM_to_dedicate = opt.fractionRAM_to_dedicate

# define the fraction of available mem
fun.fraction_available_mem = opt.fraction_available_mem
if opt.fraction_available_mem is None: fun.print_with_runtime("WARNING: You did not specify how much RAM should be used through --fraction_available_mem. perSVade will calculate this by filling the memory, which may be dangerous. If you want to use all the allocated memory you should specify --fraction_available_mem 1.0")

# print the available resources
real_available_threads = fun.get_available_threads(opt.outdir)
if opt.threads>real_available_threads:  fun.print_with_runtime("WARNING: There are %i available threads, and you required %i."%(real_available_threads, opt.threads))

available_Gb_RAM = fun.get_availableGbRAM(opt.outdir)
fun.print_with_runtime("Running perSVade %s into %s with %.3f Gb of RAM and %i cores"%(module_name, opt.outdir, available_Gb_RAM, opt.threads))

##############################

###### RUN PERSVADE IN EACH DATASET AND GET BEDPE ######

# load df
df_genomes = pd.read_csv(opt.close_shortReads_table, sep="\t")[["sampleID", "short_reads1", "short_reads2"]].set_index("sampleID")

# init df bedpe
bedpe_fields = ["chrom1", "start1", "end1", "chrom2", "start2", "end2", "ID", "score", "or1", "or2"]
df_bedpe = pd.DataFrame(columns=bedpe_fields)

# run perSVade on each sample
outdir_SVs = "%s/getting_SVs"%opt.outdir; fun.make_folder(outdir_SVs)
for sampleID, row in df_genomes.iterrows():

    # define the outdir of each sample
    outdir_sampleID = "%s/%s"%(outdir_SVs, sampleID); fun.make_folder(outdir_sampleID)

    # run each of the perSVade runs for different types of modules
    for module in ["trim_reads_and_QC", "align_reads", "call_SVs"]:
        fun.print_with_runtime("Running %s in sample %s"%(module, sampleID))

        # init the cmd with general things
        cmd = "%s %s -o %s/%s --threads %i --fractionRAM_to_dedicate %.2f"%(fun.perSVade_modules, module, outdir_sampleID, module, opt.threads, opt.fractionRAM_to_dedicate)
        if opt.verbose is True: cmd += " --verbose"
        if opt.fraction_available_mem is not None: cmd += " --fraction_available_mem %.2f"%opt.fraction_available_mem

        # add the things unique of each module or modules
        if module=="trim_reads_and_QC": cmd += " -f1 %s -f2 %s"%(row.short_reads1, row.short_reads2)
        
        if module=="align_reads":
            if opt.skip_marking_duplicates is True: cmd += " --skip_marking_duplicates"
            cmd += " -f1 %s/trim_reads_and_QC/trimmed_reads1.fastq.gz -f2 %s/trim_reads_and_QC/trimmed_reads2.fastq.gz"%(outdir_sampleID, outdir_sampleID)

        if module=="call_SVs": cmd += " --SVcalling_parameters %s --mitochondrial_chromosome %s --repeats_file %s -sbam %s/align_reads/aligned_reads.bam.sorted"%(opt.SVcalling_parameters, opt.mitochondrial_chromosome, opt.repeats_file, outdir_sampleID)

        # add things of the ref genome
        if module in {"call_SVs", "align_reads"}: cmd += " --ref %s --min_chromosome_len %i"%(opt.ref, opt.min_chromosome_len)

        # run the command
        fun.run_cmd(cmd)

    # keep the bedpe
    bedpe_file = "%s/call_SVs/gridss_output.filt.bedpe"%(outdir_sampleID)
    df_bedpe = df_bedpe.append(pd.read_csv(bedpe_file, sep="\t", names=bedpe_fields, header=-1))

# write the bedpe file
known_bedpe_breakpoints = "%s/knownSVs_breakpoints.bedpe"%opt.outdir
df_bedpe = df_bedpe.drop_duplicates(subset=["chrom1", "start1", "end1", "chrom2", "start2", "end2", "or1", "or2"])
df_bedpe.to_csv(known_bedpe_breakpoints, sep="\t", header=False, index=False)

# log
fun.print_with_runtime("All SV calling obtained")

################################################

#################################
#################################
#################################


##################################
########## CLEAN OUTPUT ##########
##################################

# clean
fun.delete_folder(outdir_SVs)

# wite final file
fun.generate_final_file_report_one_module(final_file, start_time, time.time())

# print the message
fun.print_with_runtime("perSVade %s finished correctly"%module_name)

##################################
##################################
##################################
